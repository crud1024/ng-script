class BatchPDFToPNGConverter {
  constructor(options = {}) {
    this.options = {
      dataList: options.dataList || [],
      watermark: options.watermark || "",
      watermarkOptions: {
        fontSize: options.watermarkOptions?.fontSize || 32,
        color: options.watermarkOptions?.color || "rgba(180, 180, 180, 0.6)",
        angle: options.watermarkOptions?.angle || -30,
        xSpacing: options.watermarkOptions?.xSpacing || 300,
        ySpacing: options.watermarkOptions?.ySpacing || 200,
        offsetX: options.watermarkOptions?.offsetX || 0,
        offsetY: options.watermarkOptions?.offsetY || 0,
        maxCharsPerLine: options.watermarkOptions?.maxCharsPerLine || 25,
        lineHeight: options.watermarkOptions?.lineHeight || 1.5,
        staggerOffsetX: options.watermarkOptions?.staggerOffsetX || 0.5,
        staggerOffsetY: options.watermarkOptions?.staggerOffsetY || 0.5,
        staggerEvery: options.watermarkOptions?.staggerEvery || 2,
        ...options.watermarkOptions,
      },
      baseUrl: options.baseUrl || window.location.origin,
      parentFolderName: options.parentFolderName || "资质证书",
      scale: options.scale || 2.0,
      showProgress: options.showProgress !== false,
      showNotifications: options.showNotifications !== false,
      ...options,
    };
    this.pdfLibLoaded = false;
    this.jsZipLoaded = false;
    this.currentIndex = 0;
    this.successCount = 0;
    this.failCount = 0;
    this.totalImages = 0;
    this.processedImages = 0;
    this.zip = null;
    this.startTime = null;
    this.isInitializing = false;
    this.isProcessing = false;
    this.isCancelled = false;
    this.fileStats = {
      totalFiles: 0,
      processedFiles: 0,
      totalPages: 0,
      processedPages: 0,
    };
    this.errors = [];
    this.progressContainer = null;
    this.progressBar = null;
    this.progressText = null;
    this.statusText = null;
    if (this.options.dataList && this.options.dataList.length > 0) {
      setTimeout(() => {
        this.initializeAndStart();
      }, 0);
    }
  }
  async initializeAndStart() {
    if (this.isInitializing || this.isProcessing) {
      return;
    }
    this.isInitializing = true;
    try {
      this.startTime = new Date();
      if (this.options.showProgress) {
        this.createProgressBar();
      }
      this.showInitialMessage();
      if (!this.options.dataList.length) {
        throw new Error("未选择任何单据");
      }
      if (this.options.watermark) {
        this.updateStatus(`将添加水印: "${this.options.watermark}"`);
      } else {
        this.updateStatus("不添加水印");
      }
      this.updateProgress(0, `开始处理 ${this.options.dataList.length} 个单据`);
      await this.loadRequiredLibraries();
      if (!window.JSZip) {
        throw new Error("JSZip库未正确加载");
      }
      this.zip = new JSZip();
      this.isProcessing = true;
      this.isInitializing = false;
      for (let i = 0; i < this.options.dataList.length; i++) {
        if (this.isCancelled) {
          this.updateStatus("处理已被取消");
          break;
        }
        this.currentIndex = i;
        await this.processSingleDocument(this.options.dataList[i], i);
        const progress = Math.round(
          ((i + 1) / this.options.dataList.length) * 50,
        );
        this.updateProgress(
          progress,
          `正在处理单据 ${i + 1}/${this.options.dataList.length}`,
        );
      }
      if (!this.isCancelled) {
        await this.generateAndDownloadZip();
        this.showFinalResult();
      } else {
        this.updateProgress(0, "处理已被取消");
      }
    } catch (error) {
      this.showError(error.message);
    } finally {
      this.isProcessing = false;
      this.isInitializing = false;
      setTimeout(() => {
        this.removeProgressBar();
      }, 3000);
    }
  }
  createProgressBar() {
    if (this.progressContainer) {
      this.removeProgressBar();
    }
    this.progressContainer = document.createElement("div");
    this.progressContainer.className = "batch-pdf-converter-progress";
    this.progressContainer.style.cssText =
      "position: fixed;top: 100px;right: 20px;width: 300px;background: white;border: 1px solid #ddd;border-radius: 8px;box-shadow: 0 4px 12px rgba(0,0,0,0.15);z-index: 10000;font-family: 'Microsoft YaHei', Arial, sans-serif;overflow: hidden;";
    const header = document.createElement("div");
    header.style.cssText =
      "background: #1890ff;color: white;padding: 12px 20px;font-weight: 500;font-size: 16px;display: flex;justify-content: space-between;align-items: center;box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);";
    header.innerHTML =
      '<span>证书下载进度</span><button id="batch-pdf-close" style="background:none; border:none; color:white; cursor:pointer; font-size:16px;">×</button>';
    const content = document.createElement("div");
    content.style.cssText = "padding: 16px;";
    const progressWrapper = document.createElement("div");
    progressWrapper.style.cssText = "margin-bottom: 12px;";
    const progressBarBg = document.createElement("div");
    progressBarBg.style.cssText =
      "width: 100%;height: 8px;background: #f0f0f0;border-radius: 4px;overflow: hidden;margin-bottom: 8px;";
    this.progressBar = document.createElement("div");
    this.progressBar.style.cssText =
      "width: 0%;height: 100%;background: linear-gradient(90deg, #4CAF50, #8BC34A);border-radius: 4px;transition: width 0.3s ease;";
    this.progressText = document.createElement("div");
    this.progressText.style.cssText =
      "font-size: 12px;color: #666;text-align: center;margin-bottom: 4px;";
    this.statusText = document.createElement("div");
    this.statusText.style.cssText =
      "font-size: 12px;color: #333;height: 36px;overflow: hidden;line-height: 1.4;";
    progressBarBg.appendChild(this.progressBar);
    progressWrapper.appendChild(this.progressText);
    progressWrapper.appendChild(progressBarBg);
    progressWrapper.appendChild(this.statusText);
    content.appendChild(progressWrapper);
    this.progressContainer.appendChild(header);
    this.progressContainer.appendChild(content);
    document.body.appendChild(this.progressContainer);
    const closeBtn = this.progressContainer.querySelector("#batch-pdf-close");
    if (closeBtn) {
      closeBtn.addEventListener("click", () => {
        this.removeProgressBar();
      });
    }
  }
  removeProgressBar() {
    if (this.progressContainer && this.progressContainer.parentNode) {
      this.progressContainer.parentNode.removeChild(this.progressContainer);
      this.progressContainer = null;
      this.progressBar = null;
      this.progressText = null;
      this.statusText = null;
    }
  }
  showInitialMessage() {
    const watermarkText = this.options.watermark
      ? `，将添加水印："${this.options.watermark}"`
      : "，无水印";
    const message = `开始批量处理 ${this.options.dataList.length} 个单据，一级文件夹：${this.options.parentFolderName}${watermarkText}`;
    if (
      this.options.showNotifications &&
      typeof $NG !== "undefined" &&
      $NG.message
    ) {
      $NG.message(message, "info");
    }
  }
  async loadRequiredLibraries() {
    try {
      const librariesLoaded = await this.checkLibrariesLoaded();
      if (!librariesLoaded.pdfjs) {
        await this.loadPDFJS();
      }
      if (!librariesLoaded.jszip) {
        await this.loadJSZip();
      }
    } catch (error) {
      throw new Error(`库加载失败: ${error.message}`);
    }
  }
  async checkLibrariesLoaded() {
    return {
      pdfjs: !!(window.pdfjsLib && window.pdfjsLib.GlobalWorkerOptions),
      jszip: !!window.JSZip,
    };
  }
  async loadPDFJS() {
    return new Promise((resolve, reject) => {
      if (document.querySelector('script[src*="pdf.min.js"]')) {
        const checkInterval = setInterval(() => {
          if (window.pdfjsLib && window.pdfjsLib.GlobalWorkerOptions) {
            clearInterval(checkInterval);
            this.pdfLibLoaded = true;
            resolve();
          }
        }, 100);
        setTimeout(() => {
          clearInterval(checkInterval);
          reject(new Error("PDF.js加载超时"));
        }, 10000);
        return;
      }
      const script = document.createElement("script");
      script.src =
        "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js";
      script.crossOrigin = "anonymous";
      script.id = "pdfjs-library";
      script.onload = () => {
        setTimeout(() => {
          if (!window.pdfjsLib) {
            reject(new Error("PDF.js加载后未正确初始化"));
            return;
          }
          window.pdfjsLib.GlobalWorkerOptions.workerSrc =
            "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
          this.pdfLibLoaded = true;
          resolve();
        }, 100);
      };
      script.onerror = () => {
        reject(new Error("PDF.js库加载失败，请检查网络连接"));
      };
      document.head.appendChild(script);
    });
  }
  async loadJSZip() {
    return new Promise((resolve, reject) => {
      if (document.querySelector('script[src*="jszip.min.js"]')) {
        const checkInterval = setInterval(() => {
          if (window.JSZip) {
            clearInterval(checkInterval);
            this.jsZipLoaded = true;
            resolve();
          }
        }, 100);
        setTimeout(() => {
          clearInterval(checkInterval);
          reject(new Error("JSZip加载超时"));
        }, 10000);
        return;
      }
      const script = document.createElement("script");
      script.src =
        "https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js";
      script.crossOrigin = "anonymous";
      script.id = "jszip-library";
      script.onload = () => {
        setTimeout(() => {
          if (!window.JSZip) {
            reject(new Error("JSZip加载后未正确初始化"));
            return;
          }
          this.jsZipLoaded = true;
          resolve();
        }, 100);
      };
      script.onerror = () => {
        reject(new Error("JSZip库加载失败，请检查网络连接"));
      };
      document.head.appendChild(script);
    });
  }
  async processSingleDocument(item, index) {
    if (this.isCancelled) {
      return;
    }
    const itemName =
      item.u_cert_name_level_EXName || item.u_zwmc || `单据_${index + 1}`;
    try {
      const url = this.buildSingleFileUrl(item);
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      const blob = await response.blob();
      const folderName = this.getSecondFolderName(item);
      if (blob.type.includes("zip") || blob.type.includes("application/zip")) {
        await this.handleZipFile(blob, item, folderName);
      } else if (
        blob.type.includes("pdf") ||
        blob.type.includes("application/pdf")
      ) {
        await this.convertSinglePDF(blob, item, folderName);
      } else {
        throw new Error(`不支持的文件格式: ${blob.type}`);
      }
      this.successCount++;
    } catch (error) {
      this.failCount++;
      this.errors.push({
        index: index + 1,
        name: itemName,
        error: error.message,
      });
    }
  }
  buildSingleFileUrl(item) {
    const phId = item.u_cert_name_level || "";
    const asrFid = item.u_zswj || "";
    const fileName = item.u_zwmc || "资质证书";
    return (
      `${this.options.baseUrl}/prp-gateway/downLoadFileV2?` +
      `tableName=p_form_certificate_reg_m&` +
      `phId=${phId}&` +
      `filesName=${encodeURIComponent(fileName)}&` +
      `asrFid=${asrFid}`
    );
  }
  getSecondFolderName(item) {
    let folderName = item.u_cert_name_level_EXName || item.u_zwmc || "未知单据";
    folderName = this.cleanFolderName(folderName);
    if (!folderName.trim()) {
      folderName = `单据_${item.u_cert_name_level || Date.now()}`;
    }
    return folderName;
  }
  cleanFolderName(name) {
    if (!name || typeof name !== "string") {
      return "未知文件夹";
    }
    return name
      .replace(/[\\/:*?"<>|]/g, "_")
      .replace(/\.\.\./g, "_")
      .replace(/\s+/g, " ")
      .trim()
      .substring(0, 100);
  }
  cleanFilename(filename) {
    if (!filename || typeof filename !== "string") {
      return "document";
    }
    return filename
      .replace(/[\\/:*?"<>|]/g, "_")
      .replace(/\s+/g, "_")
      .trim()
      .substring(0, 50);
  }
  async convertSinglePDF(blob, item, folderName) {
    if (this.isCancelled) {
      return;
    }
    const arrayBuffer = await this.blobToArrayBuffer(blob);
    if (!this.isValidPDF(arrayBuffer)) {
      throw new Error("无效的PDF文件格式");
    }
    const loadingTask = window.pdfjsLib.getDocument({ data: arrayBuffer });
    const pdf = await loadingTask.promise;
    this.fileStats.totalPages += pdf.numPages;
    const baseFilename = item.u_zwmc || "资质证书";
    const cleanName = this.cleanFilename(baseFilename);
    for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
      if (this.isCancelled) {
        return;
      }
      try {
        await this.convertPage(pdf, pageNum, cleanName, folderName);
        this.fileStats.processedPages++;
        if (pageNum % 5 === 0 || pageNum === pdf.numPages) {
          const progress =
            50 +
            Math.round(
              (this.processedImages / Math.max(this.totalImages, 1)) * 50,
            );
          this.updateProgress(
            Math.min(progress, 90),
            `正在转换图片 ${pageNum}/${pdf.numPages}`,
          );
        }
      } catch (pageError) {
        throw new Error(`第 ${pageNum} 页转换失败: ${pageError.message}`);
      }
    }
  }
  async convertPage(pdf, pageNum, baseName, folderName) {
    try {
      const page = await pdf.getPage(pageNum);
      const viewport = page.getViewport({ scale: this.options.scale });
      const canvas = document.createElement("canvas");
      const context = canvas.getContext("2d");
      canvas.width = viewport.width;
      canvas.height = viewport.height;
      const renderContext = { canvasContext: context, viewport: viewport };
      await page.render(renderContext).promise;
      if (this.options.watermark) {
        this.addWatermarkToCanvas(canvas, context);
      }
      const pngBlob = await new Promise((resolve, reject) => {
        canvas.toBlob(
          (blob) => {
            if (blob) {
              resolve(blob);
            } else {
              reject(new Error("Canvas转换PNG失败"));
            }
          },
          "image/png",
          0.95,
        );
      });
      const filename = `${baseName}_${pageNum.toString().padStart(3, "0")}.png`;
      const filePath = `${this.options.parentFolderName}/${folderName}/${filename}`;
      if (this.zip) {
        this.zip.file(filePath, pngBlob);
      }
      this.totalImages++;
      this.processedImages++;
      canvas.width = 0;
      canvas.height = 0;
      return filePath;
    } catch (error) {
      throw error;
    }
  }
  addWatermarkToCanvas(canvas, context) {
    if (!this.options.watermark) return;
    const { watermark, watermarkOptions } = this.options;
    const {
      fontSize,
      color,
      angle,
      xSpacing,
      ySpacing,
      offsetX,
      offsetY,
      maxCharsPerLine,
      lineHeight,
      staggerOffsetX,
      staggerOffsetY,
      staggerEvery,
    } = watermarkOptions;
    const maxChars = maxCharsPerLine || 25;
    const lineHeightRatio = lineHeight || 1.5;
    const staggerXOffset = staggerOffsetX || 0.5;
    const staggerYOffset = staggerOffsetY || 0.5;
    const staggerCount = staggerEvery || 2;
    const watermarkLines = this.splitWatermarkText(watermark, maxChars);
    const lineSpacing = fontSize * 0.2;
    const textBlockHeight = (fontSize + lineSpacing) * watermarkLines.length;
    context.save();
    context.font = `bold ${fontSize}px Arial, sans-serif`;
    context.fillStyle = color;
    context.textAlign = "center";
    context.textBaseline = "middle";
    let maxTextWidth = 0;
    for (const line of watermarkLines) {
      const textMetrics = context.measureText(line);
      maxTextWidth = Math.max(maxTextWidth, textMetrics.width);
    }
    const actualXSpacing = Math.max(xSpacing, maxTextWidth * 1.5);
    const actualYSpacing = Math.max(ySpacing, textBlockHeight * 2);
    context.translate(canvas.width / 2 + offsetX, canvas.height / 2 + offsetY);
    context.rotate((angle * Math.PI) / 180);
    const halfWidth =
      Math.sqrt(canvas.width * canvas.width + canvas.height * canvas.height) /
      2;
    const halfHeight = halfWidth;
    const cols = Math.ceil((halfWidth * 2) / actualXSpacing) + 2;
    const rows = Math.ceil((halfHeight * 2) / actualYSpacing) + 2;
    for (let i = -cols; i <= cols; i++) {
      for (let j = -rows; j <= rows; j++) {
        const x = i * actualXSpacing;
        const y = j * actualYSpacing;
        let staggerX = 0;
        let staggerY = 0;
        if ((i + j) % staggerCount === 0) {
          staggerX = actualXSpacing * staggerXOffset;
          staggerY = actualYSpacing * staggerYOffset;
        }
        if (
          Math.abs(x + staggerX) < halfWidth + maxTextWidth / 2 &&
          Math.abs(y + staggerY) < halfHeight + textBlockHeight / 2
        ) {
          this.drawWatermarkLines(
            context,
            watermarkLines,
            x + staggerX,
            y + staggerY,
            fontSize,
            lineHeightRatio,
          );
        }
      }
    }
    context.restore();
  }
  splitWatermarkText(text, maxCharsPerLine = 25) {
    if (!text) return [];
    const lines = [];
    const words = text.split("");
    let currentLine = "";
    for (let i = 0; i < words.length; i++) {
      const isChinese = /[\u4e00-\u9fff]/.test(words[i]);
      const charWidth = isChinese ? 2 : 1;
      if (currentLine.length + charWidth > maxCharsPerLine) {
        if (currentLine.trim()) {
          lines.push(currentLine.trim());
        }
        currentLine = words[i];
      } else {
        currentLine += words[i];
      }
    }
    if (currentLine.trim()) {
      lines.push(currentLine.trim());
    }
    if (lines.length > 3) {
      return lines
        .slice(0, 3)
        .map((line, index) =>
          index === 2 ? line.substring(0, maxCharsPerLine - 3) + "..." : line,
        );
    }
    return lines;
  }
  drawWatermarkLines(context, lines, x, y, fontSize, lineHeight) {
    if (!lines || lines.length === 0) return;
    const lineSpacing = fontSize * 0.2;
    const totalHeight = (fontSize + lineSpacing) * lines.length;
    const startY = y - totalHeight / 2 + fontSize / 2;
    for (let i = 0; i < lines.length; i++) {
      const lineY = startY + i * (fontSize + lineSpacing) * lineHeight;
      context.fillText(lines[i], x, lineY);
    }
  }
  async handleZipFile(zipBlob, item, folderName) {
    try {
      if (this.isCancelled) {
        return;
      }
      const zip = await JSZip.loadAsync(zipBlob);
      const pdfFiles = Object.keys(zip.files).filter(
        (filename) =>
          !zip.files[filename].dir && filename.toLowerCase().endsWith(".pdf"),
      );
      if (pdfFiles.length === 0) {
        throw new Error("ZIP文件中未找到PDF文件");
      }
      for (const filename of pdfFiles) {
        if (this.isCancelled) {
          return;
        }
        const pdfFile = zip.files[filename];
        const pdfBlob = await pdfFile.async("blob");
        const pdfName = filename
          .replace(/\.pdf$/i, "")
          .replace(/\.[^/.]+$/, "");
        await this.convertSinglePDF(
          pdfBlob,
          { ...item, u_zwmc: pdfName || filename },
          folderName,
        );
      }
    } catch (error) {
      throw new Error(`ZIP文件处理失败: ${error.message}`);
    }
  }
  blobToArrayBuffer(blob) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result);
      reader.onerror = () => reject(new Error("Blob读取失败"));
      reader.readAsArrayBuffer(blob);
    });
  }
  isValidPDF(arrayBuffer) {
    try {
      if (!arrayBuffer || arrayBuffer.byteLength < 4) {
        return false;
      }
      const uint8Array = new Uint8Array(arrayBuffer);
      const header = String.fromCharCode(...uint8Array.slice(0, 4));
      return header === "%PDF";
    } catch (error) {
      return false;
    }
  }
  async generateAndDownloadZip() {
    if (!this.zip || Object.keys(this.zip.files).length === 0) {
      throw new Error("没有文件可以压缩");
    }
    this.updateProgress(90, "正在生成ZIP文件...");
    try {
      const zipBlob = await this.zip.generateAsync({
        type: "blob",
        compression: "DEFLATE",
        compressionOptions: { level: 6 },
        comment: `生成时间: ${new Date().toLocaleString()}\n总文件数: ${this.totalImages}\n一级文件夹: ${this.options.parentFolderName}\n水印: ${this.options.watermark || "无"}`,
      });
      this.updateProgress(95, "ZIP文件生成完成，开始下载...");
      await this.downloadZipFile(zipBlob);
      this.updateProgress(100, "下载完成！");
    } catch (error) {
      throw new Error(`ZIP文件生成失败: ${error.message}`);
    }
  }
  async downloadZipFile(blob) {
    return new Promise((resolve, reject) => {
      try {
        const timestamp = new Date()
          .toISOString()
          .replace(/[:.]/g, "-")
          .slice(0, 19);
        const zipFilename = `${this.cleanFilename(this.options.parentFolderName)}_${timestamp}.zip`;
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = zipFilename;
        link.style.display = "none";
        document.body.appendChild(link);
        link.click();
        setTimeout(() => {
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
          resolve();
        }, 100);
      } catch (error) {
        reject(new Error(`下载失败: ${error.message}`));
      }
    });
  }
  updateProgress(percent, message = "") {
    const progressText = `进度: ${Math.min(percent, 100)}% - ${this.successCount}成功, ${this.failCount}失败`;
    if (this.progressBar && this.progressText && this.statusText) {
      this.progressBar.style.width = `${Math.min(percent, 100)}%`;
      this.progressText.textContent = progressText;
      this.statusText.textContent = message;
    }
    if (
      this.options.showNotifications &&
      typeof $NG !== "undefined" &&
      $NG.message
    ) {
      $NG.message(`${progressText} ${message}`, "info");
    }
  }
  updateStatus(message) {
    if (this.statusText) {
      this.statusText.textContent = message;
    }
  }
  showFinalResult() {
    const endTime = new Date();
    const duration = Math.round((endTime - this.startTime) / 1000);
    const watermarkText = this.options.watermark
      ? `水印: "${this.options.watermark}"`
      : "水印: 无";
    const resultText = `处理完成！\n总单据: ${this.options.dataList.length}个\n成功: ${this.successCount}个\n失败: ${this.failCount}个\n总图片: ${this.totalImages}张\n总页数: ${this.fileStats.totalPages}页\n${watermarkText}\n处理时间: ${duration}秒`;
    if (this.statusText) {
      this.statusText.textContent = "处理完成！正在关闭进度条...";
      if (this.progressBar) {
        this.progressBar.style.background = "#4CAF50";
      }
    }
    if (this.options.showNotifications && typeof $NG !== "undefined") {
      if (this.failCount === 0) {
        $NG.message(resultText, "success");
      } else {
        let errorDetails = "失败详情:\n";
        this.errors.forEach((error) => {
          errorDetails += `${error.index}. ${error.name}: ${error.error}\n`;
        });
        $NG.message(`${resultText}\n\n${errorDetails}`, "warning");
      }
    }
  }
  showError(message) {
    if (this.statusText) {
      this.statusText.textContent = `错误: ${message}`;
      if (this.progressBar) {
        this.progressBar.style.background = "#f44336";
      }
    }
    if (
      this.options.showNotifications &&
      typeof $NG !== "undefined" &&
      $NG.message
    ) {
      $NG.message("处理失败: " + message, "error");
    }
  }
  formatFileSize(bytes) {
    if (bytes === 0) return "0 Bytes";
    const k = 1024;
    const sizes = ["Bytes", "KB", "MB", "GB"];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
  }
  cancel() {
    this.isCancelled = true;
    if (this.statusText) {
      this.statusText.textContent = "处理已取消";
      if (this.progressBar) {
        this.progressBar.style.background = "#9E9E9E";
      }
    }
  }
  getStatus() {
    return {
      isInitializing: this.isInitializing,
      isProcessing: this.isProcessing,
      isCancelled: this.isCancelled,
      successCount: this.successCount,
      failCount: this.failCount,
      totalImages: this.totalImages,
      errors: this.errors,
      watermark: this.options.watermark,
      watermarkOptions: this.options.watermarkOptions,
    };
  }
  setWatermark(text, options = {}) {
    this.options.watermark = text || "";
    if (options) {
      this.options.watermarkOptions = {
        ...this.options.watermarkOptions,
        ...options,
      };
    }
  }
  removeWatermark() {
    this.options.watermark = "";
  }
  toggleProgressBar(show) {
    this.options.showProgress = show;
    if (show && !this.progressContainer) {
      this.createProgressBar();
    } else if (!show && this.progressContainer) {
      this.removeProgressBar();
    }
  }
}
if (typeof window !== "undefined") {
  window.BatchPDFToPNGConverter = BatchPDFToPNGConverter;
}
